{"version":3,"sources":["file:///G:/escapeworm/NewProject/assets/scripts/utils/PathFinder.ts"],"names":["PathFinder","Vec2","findPath","headPos","direction","wormLength","segments","matrixWidth","matrixHeight","obstacles","escapePoints","directionVec","getDirectionVector","simulatedSegments","map","s","x","y","currentX","currentY","path","nextX","nextY","push","i","extraX","extraY","canEscape","isHeadObstacle","some","obs","pathToObstacle","bodyCollision","nextSegmentPos","isBodyObstacle","length","dirMap"],"mappings":"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","sourcesContent":["/**\r\n * 路径查找工具类\r\n * 使用直线路径查找蠕虫从当前位置到边界的逃脱路径\r\n */\r\nimport { Vec2 } from 'cc';\r\n\r\nexport interface PathResult {\r\n    canEscape: boolean;\r\n    path: Vec2[];\r\n    pathToObstacle?: Vec2[];\r\n}\r\n\r\nexport class PathFinder {\r\n    /**\r\n     * 查找从蠕虫当前位置到边界的路径\r\n     * 蠕虫只能沿着头部方向向前移动，不能拐弯\r\n     */\r\n    static findPath(\r\n        headPos: Vec2,\r\n        direction: string,\r\n        wormLength: number,\r\n        segments: Vec2[],\r\n        matrixWidth: number,\r\n        matrixHeight: number,\r\n        obstacles: Vec2[],\r\n        escapePoints: Vec2[]\r\n    ): PathResult {\r\n        const directionVec = this.getDirectionVector(direction);\r\n        // 创建蠕虫段的副本，用于模拟移动\r\n        let simulatedSegments = segments.map(s => new Vec2(s.x, s.y));\r\n\r\n        let currentX = headPos.x;\r\n        let currentY = headPos.y;\r\n        const path: Vec2[] = [];\r\n\r\n        while (true) {\r\n            const nextX = currentX + directionVec.x;\r\n            const nextY = currentY + directionVec.y;\r\n\r\n            // 检查是否超出边界（可以逃脱）\r\n            if (nextX < 0 || nextX >= matrixWidth || nextY < 0 || nextY >= matrixHeight) {\r\n                // 可以逃脱，添加到路径\r\n                path.push(new Vec2(nextX, nextY));\r\n\r\n                // 继续添加额外的步数，让整个蠕虫都能离开屏幕\r\n                for (let i = 1; i < wormLength; i++) {\r\n                    const extraX = nextX + directionVec.x * i;\r\n                    const extraY = nextY + directionVec.y * i;\r\n                    path.push(new Vec2(extraX, extraY));\r\n                }\r\n\r\n                return { canEscape: true, path: path };\r\n            }\r\n\r\n            // 检查头部位置是否是障碍物\r\n            const isHeadObstacle = obstacles.some(obs => obs.x === nextX && obs.y === nextY);\r\n            if (isHeadObstacle) {\r\n                return { canEscape: false, path: [], pathToObstacle: path };\r\n            }\r\n\r\n            // 检查蠕虫的身体段在移动后是否会与障碍物碰撞\r\n            let bodyCollision = false;\r\n            for (let i = 0; i < simulatedSegments.length - 1; i++) {\r\n                const nextSegmentPos = new Vec2(simulatedSegments[i].x, simulatedSegments[i].y);\r\n                const isBodyObstacle = obstacles.some(obs =>\r\n                    obs.x === nextSegmentPos.x && obs.y === nextSegmentPos.y\r\n                );\r\n\r\n                if (isBodyObstacle) {\r\n                    bodyCollision = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (bodyCollision) {\r\n                return { canEscape: false, path: [], pathToObstacle: path };\r\n            }\r\n\r\n            // 继续前进\r\n            path.push(new Vec2(nextX, nextY));\r\n            currentX = nextX;\r\n            currentY = nextY;\r\n\r\n            // 更新模拟的蠕虫段位置\r\n            for (let i = simulatedSegments.length - 1; i > 0; i--) {\r\n                simulatedSegments[i] = new Vec2(simulatedSegments[i - 1].x, simulatedSegments[i - 1].y);\r\n            }\r\n            simulatedSegments[0] = new Vec2(nextX, nextY);\r\n\r\n            // 防止无限循环\r\n            if (path.length > matrixWidth * matrixHeight) {\r\n                return { canEscape: false, path: [], pathToObstacle: [] };\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取蠕虫朝向对应的方向向量\r\n     */\r\n    static getDirectionVector(direction: string): Vec2 {\r\n        const dirMap: { [key: string]: Vec2 } = {\r\n            'up': new Vec2(0, -1),\r\n            'down': new Vec2(0, 1),\r\n            'left': new Vec2(-1, 0),\r\n            'right': new Vec2(1, 0)\r\n        };\r\n        return dirMap[direction] || new Vec2(0, 0);\r\n    }\r\n}\r\n\r\n"]}