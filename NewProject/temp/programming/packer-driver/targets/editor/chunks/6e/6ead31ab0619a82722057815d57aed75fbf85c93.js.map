{"version":3,"sources":["file:///G:/escapeworm/NewProject/assets/scripts/utils/PathFinder.ts"],"names":["PathFinder","Vec2","findPath","headPos","direction","wormLength","segments","matrixWidth","matrixHeight","obstacles","escapePoints","directionVec","getDirectionVector","simulatedSegments","map","s","x","y","currentX","currentY","path","nextX","nextY","push","i","extraX","extraY","canEscape","isHeadObstacle","some","obs","pathToObstacle","bodyCollision","length","nextSegmentPos","isBodyObstacle","escapePoint","dirMap"],"mappings":"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","sourcesContent":["/**\r\n * 路径查找工具类\r\n * 使用直线路径查找蠕虫从当前位置到边界的逃脱路径\r\n */\r\nimport { Vec2 } from 'cc';\r\n\r\nexport interface PathResult {\r\n    canEscape: boolean;\r\n    path: Vec2[];\r\n    pathToObstacle?: Vec2[];\r\n}\r\n\r\nexport class PathFinder {\r\n    /**\r\n     * 查找从蠕虫当前位置到边界的路径\r\n     * 蠕虫只能沿着头部方向向前移动，不能拐弯\r\n     */\r\n    static findPath(\r\n        headPos: Vec2,\r\n        direction: string,\r\n        wormLength: number,\r\n        segments: Vec2[],\r\n        matrixWidth: number,\r\n        matrixHeight: number,\r\n        obstacles: Vec2[],\r\n        escapePoints: Vec2[]\r\n    ): PathResult {\r\n        const directionVec = this.getDirectionVector(direction);\r\n        // 创建蠕虫段的副本，用于模拟移动\r\n        let simulatedSegments = segments.map(s => new Vec2(s.x, s.y));\r\n\r\n        let currentX = headPos.x;\r\n        let currentY = headPos.y;\r\n        const path: Vec2[] = [];\r\n\r\n        while (true) {\r\n            const nextX = currentX + directionVec.x;\r\n            const nextY = currentY + directionVec.y;\r\n\r\n            // 检查是否超出边界（可以逃脱）\r\n            if (nextX < 0 || nextX >= matrixWidth || nextY < 0 || nextY >= matrixHeight) {\r\n                // 可以逃脱，添加到路径\r\n                path.push(new Vec2(nextX, nextY));\r\n\r\n                // 继续添加额外的步数，让整个蠕虫都能离开屏幕\r\n                for (let i = 1; i < wormLength; i++) {\r\n                    const extraX = nextX + directionVec.x * i;\r\n                    const extraY = nextY + directionVec.y * i;\r\n                    path.push(new Vec2(extraX, extraY));\r\n                }\r\n\r\n                return { canEscape: true, path: path };\r\n            }\r\n\r\n            // 检查头部位置是否是障碍物\r\n            const isHeadObstacle = obstacles.some(obs => obs.x === nextX && obs.y === nextY);\r\n            if (isHeadObstacle) {\r\n                return { canEscape: false, path: [], pathToObstacle: path };\r\n            }\r\n\r\n            // 检查蠕虫的身体段在移动后是否会与障碍物碰撞\r\n            let bodyCollision = false;\r\n            for (let i = 0; i < simulatedSegments.length - 1; i++) {\r\n                const nextSegmentPos = new Vec2(simulatedSegments[i].x, simulatedSegments[i].y);\r\n                const isBodyObstacle = obstacles.some(obs =>\r\n                    obs.x === nextSegmentPos.x && obs.y === nextSegmentPos.y\r\n                );\r\n\r\n                if (isBodyObstacle) {\r\n                    bodyCollision = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (bodyCollision) {\r\n                return { canEscape: false, path: [], pathToObstacle: path };\r\n            }\r\n\r\n            // 检查是否到达逃脱点\r\n            for (const escapePoint of escapePoints) {\r\n                if (nextX === escapePoint.x && nextY === escapePoint.y) {\r\n                    path.push(new Vec2(nextX, nextY));\r\n                    return { canEscape: true, path: path };\r\n                }\r\n            }\r\n\r\n            // 继续前进\r\n            path.push(new Vec2(nextX, nextY));\r\n            currentX = nextX;\r\n            currentY = nextY;\r\n\r\n            // 更新模拟的蠕虫段位置\r\n            for (let i = simulatedSegments.length - 1; i > 0; i--) {\r\n                simulatedSegments[i] = new Vec2(simulatedSegments[i - 1].x, simulatedSegments[i - 1].y);\r\n            }\r\n            simulatedSegments[0] = new Vec2(nextX, nextY);\r\n\r\n            // 防止无限循环\r\n            if (path.length > matrixWidth * matrixHeight) {\r\n                return { canEscape: false, path: [], pathToObstacle: [] };\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取蠕虫朝向对应的方向向量\r\n     */\r\n    static getDirectionVector(direction: string): Vec2 {\r\n        const dirMap: { [key: string]: Vec2 } = {\r\n            'up': new Vec2(0, -1),\r\n            'down': new Vec2(0, 1),\r\n            'left': new Vec2(-1, 0),\r\n            'right': new Vec2(1, 0)\r\n        };\r\n        return dirMap[direction] || new Vec2(0, 0);\r\n    }\r\n}\r\n\r\n"]}