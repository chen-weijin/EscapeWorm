{"version":3,"sources":["file:///G:/escapeworm/NewProject/assets/scripts/utils/CollisionDetector.ts"],"names":["CollisionDetector","Vec2","PathFinder","checkCollision","worm","newPosition","allWorms","otherWorm","id","isEscaped","isEscaping","isAnimating","segment","segments","x","y","willCollide","headPos","direction","getDirectionVector","nextPosition","isInBounds","position","matrixWidth","matrixHeight","isPositionOccupied","excludeWormId"],"mappings":";;;iGAeaA,iB;;;;;;;;;;;;;;;AAZJC,MAAAA,I,OAAAA,I;;AACAC,MAAAA,U,iBAAAA,U;;;;;;AAJT;AACA;AACA;;;;;mCAaaF,iB,GAAN,MAAMA,iBAAN,CAAwB;AAC3B;AACJ;AACA;AACyB,eAAdG,cAAc,CAACC,IAAD,EAAiBC,WAAjB,EAAoCC,QAApC,EAAmE;AACpF,eAAK,MAAMC,SAAX,IAAwBD,QAAxB,EAAkC;AAC9B;AACA,gBAAIC,SAAS,CAACC,EAAV,KAAiBJ,IAAI,CAACI,EAA1B,EAA8B;AAC1B;AACH,aAJ6B,CAM9B;;;AACA,gBAAID,SAAS,CAACE,SAAd,EAAyB;AACrB;AACH,aAT6B,CAW9B;;;AACA,gBAAIF,SAAS,CAACG,UAAd,EAA0B;AACtB;AACH,aAd6B,CAgB9B;;;AACA,gBAAIH,SAAS,CAACI,WAAd,EAA2B;AACvB;AACH,aAnB6B,CAqB9B;;;AACA,iBAAK,MAAMC,OAAX,IAAsBL,SAAS,CAACM,QAAhC,EAA0C;AACtC,kBAAID,OAAO,CAACE,CAAR,KAAcT,WAAW,CAACS,CAA1B,IAA+BF,OAAO,CAACG,CAAR,KAAcV,WAAW,CAACU,CAA7D,EAAgE;AAC5D,uBAAO,IAAP;AACH;AACJ;AACJ;;AAED,iBAAO,KAAP;AACH;AAED;AACJ;AACA;;;AACsB,eAAXC,WAAW,CAACZ,IAAD,EAAiBE,QAAjB,EAAgD;AAC9D,gBAAMW,OAAO,GAAGb,IAAI,CAACS,QAAL,CAAc,CAAd,CAAhB;AACA,gBAAMK,SAAS,GAAG;AAAA;AAAA,wCAAWC,kBAAX,CAA8Bf,IAAI,CAACc,SAAnC,CAAlB;AACA,gBAAME,YAAY,GAAG,IAAInB,IAAJ,CAASgB,OAAO,CAACH,CAAR,GAAYI,SAAS,CAACJ,CAA/B,EAAkCG,OAAO,CAACF,CAAR,GAAYG,SAAS,CAACH,CAAxD,CAArB;AAEA,iBAAO,KAAKZ,cAAL,CAAoBC,IAApB,EAA0BgB,YAA1B,EAAwCd,QAAxC,CAAP;AACH;AAED;AACJ;AACA;;;AACqB,eAAVe,UAAU,CAACC,QAAD,EAAiBC,WAAjB,EAAsCC,YAAtC,EAAqE;AAClF,iBAAOF,QAAQ,CAACR,CAAT,IAAc,CAAd,IAAmBQ,QAAQ,CAACR,CAAT,GAAaS,WAAhC,IACHD,QAAQ,CAACP,CAAT,IAAc,CADX,IACgBO,QAAQ,CAACP,CAAT,GAAaS,YADpC;AAEH;AAED;AACJ;AACA;;;AAC6B,eAAlBC,kBAAkB,CAACH,QAAD,EAAiBhB,QAAjB,EAAuCoB,aAA4B,GAAG,IAAtE,EAAqF;AAC1G,eAAK,MAAMtB,IAAX,IAAmBE,QAAnB,EAA6B;AACzB,gBAAIoB,aAAa,KAAK,IAAlB,IAA0BtB,IAAI,CAACI,EAAL,KAAYkB,aAA1C,EAAyD;AACrD;AACH;;AAED,iBAAK,MAAMd,OAAX,IAAsBR,IAAI,CAACS,QAA3B,EAAqC;AACjC,kBAAID,OAAO,CAACE,CAAR,KAAcQ,QAAQ,CAACR,CAAvB,IAA4BF,OAAO,CAACG,CAAR,KAAcO,QAAQ,CAACP,CAAvD,EAA0D;AACtD,uBAAO,IAAP;AACH;AACJ;AACJ;;AACD,iBAAO,KAAP;AACH;;AAxE0B,O","sourcesContent":["/**\r\n * 碰撞检测工具类\r\n */\r\nimport { Vec2 } from 'cc';\r\nimport { PathFinder } from './PathFinder';\r\n\r\nexport interface WormLike {\r\n    id: number;\r\n    segments: Vec2[];\r\n    direction: string;\r\n    isEscaped: boolean;\r\n    isEscaping: boolean;\r\n    isAnimating: boolean;\r\n}\r\n\r\nexport class CollisionDetector {\r\n    /**\r\n     * 检测蠕虫移动到新位置是否会碰撞\r\n     */\r\n    static checkCollision(worm: WormLike, newPosition: Vec2, allWorms: WormLike[]): boolean {\r\n        for (const otherWorm of allWorms) {\r\n            // 跳过自己\r\n            if (otherWorm.id === worm.id) {\r\n                continue;\r\n            }\r\n\r\n            // 跳过已逃脱的蠕虫\r\n            if (otherWorm.isEscaped) {\r\n                continue;\r\n            }\r\n\r\n            // 跳过正在逃脱的蠕虫\r\n            if (otherWorm.isEscaping) {\r\n                continue;\r\n            }\r\n\r\n            // 跳过正在移动的蠕虫\r\n            if (otherWorm.isAnimating) {\r\n                continue;\r\n            }\r\n\r\n            // 检查新位置是否与其他蠕虫的任何段重叠\r\n            for (const segment of otherWorm.segments) {\r\n                if (segment.x === newPosition.x && segment.y === newPosition.y) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * 预测蠕虫下一步是否会碰撞\r\n     */\r\n    static willCollide(worm: WormLike, allWorms: WormLike[]): boolean {\r\n        const headPos = worm.segments[0];\r\n        const direction = PathFinder.getDirectionVector(worm.direction);\r\n        const nextPosition = new Vec2(headPos.x + direction.x, headPos.y + direction.y);\r\n\r\n        return this.checkCollision(worm, nextPosition, allWorms);\r\n    }\r\n\r\n    /**\r\n     * 检查位置是否在矩阵范围内\r\n     */\r\n    static isInBounds(position: Vec2, matrixWidth: number, matrixHeight: number): boolean {\r\n        return position.x >= 0 && position.x < matrixWidth &&\r\n            position.y >= 0 && position.y < matrixHeight;\r\n    }\r\n\r\n    /**\r\n     * 检查位置是否与其他蠕虫的任何部分重叠\r\n     */\r\n    static isPositionOccupied(position: Vec2, allWorms: WormLike[], excludeWormId: number | null = null): boolean {\r\n        for (const worm of allWorms) {\r\n            if (excludeWormId !== null && worm.id === excludeWormId) {\r\n                continue;\r\n            }\r\n\r\n            for (const segment of worm.segments) {\r\n                if (segment.x === position.x && segment.y === position.y) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n"]}